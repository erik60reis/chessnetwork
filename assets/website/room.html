<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess</title>
    <style>
        .game-container {
            width: 100%;
            height: 100%;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #gameimage {
            width: 85%;
            height: auto;
        }

        #gameboard {
            width: 85%;
        }

        input {
            border-radius: 5px;
            width: 200px;
        }

        .playerInfo {
            font-size: 15px;
        }

        cg-container {
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        @media (min-width: 600px) {
            #gameimage {
                height: 85vh;
                width: auto;
            }
            #gameboard {
                height: 85vh;
            }
            input {
                width: 500px;
            }
            .playerInfo {
                font-size: 25px;
            }
        }
    </style>
    <link rel="stylesheet" href="/assets/stylesheets/chessground.base.css">
    <link rel="stylesheet" href="/assets/stylesheets/chessground.board.css">
    <span id="piecesstyle"></span>
</head>
<body>
    <div class="game-container">
        <div id="gamestatus"> ---- </div>
        <img id="gameimage">
        <div class="playerInfo" id="otherData"></div>
        <div id="gameboard"></div>
        <div class="playerInfo" id="yourData"></div>
        <br/>
        <br/>
        <input id="moveinput" type="text" placeholder="Enter move... (eg. e2e4 or 21-17)"/> <button id="movebutton">MOVE</button>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    </div>

    <script>
        var ChessgroundJS = null;
    </script>
    <script type="module">
        import { Chessground } from "/assets/chessgroundx/chessground.js"
        ChessgroundJS = Chessground;
    </script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        function chessSquareToCheckersIndex(chessNotation, rankCount = 8, fileCount = 8) {
            const col = chessNotation.charAt(0).toLowerCase();
            const row = parseInt(chessNotation.charAt(1), 10);

            let index = (((rankCount - row) * fileCount));

            if ((rankCount - row) % 2 !== 0) {
                index += col.charCodeAt(0) - 97 + 1;
            } else {
                index += col.charCodeAt(0) - 97;
            }

            index /= 2;
            index += 1;

            return index;
        }

        function getDests(legalMoves, boardranks) {
            var moves = new Map();
            var letters = 'abcdefghijklmnopqrstuvwxyz';
            letters.split("").forEach((letter) => {
                for (let number = 1; number <= boardranks; number++) {
                    let legalMovesFormatted = [];
                    legalMoves.forEach(legalMove => {
                        if (legalMove.startsWith((letter + number))) {
                            legalMovesFormatted.push(legalMove[2] + legalMove[3]);
                        }
                    });
                    moves.set((letter + number), legalMovesFormatted);
                }
            });
            return moves;
        }

        let roomId = {{roomId}};

        let board = null;
        
        let socket;

        var chessgroundconfig = {

            fen: 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1', // starting FEN

            orientation: 'white', // board orientation

            turnColor: 'white', // board orientation

            coordinates: true, // show ranks and files

            autoCastle: true, // automatically castle when king/rook move

            viewOnly: false, // restrict premoves, clicks, drag pieces

            disableContextMenu: false, // disable right click

            resizable: true, // allow resize

            animation: {
                enabled: true,
                duration: 200
            }, 

            movable: {
                free: false, // all moves are valid - no validation
                color: 'both', // allow both whites and blacks to move
                showDests: true, // highlight destinations
                dests: null,
                rookCastle: true
            },

            drawable: {
                enabled: true,
                visible: true,
            },

            premovable: {
                enabled: false, // false for now
                events: {
                    set: function(orig, dest) {
                        selectedpremove = {
                            from: orig,
                            to: dest,
                            promotion: promotion
                        };
                    },
                    unset: function() {
                        selectedpremove = null;
                    }
                }
            },

            predroppable: {
                enabled: false // disable predrops
            },

            highlight: {
                lastMove: true, // highlight last move
                check: true // highlight checks
            },

            events: {
                move: (orig, dest) => {
                    socket.emit('makeMove', orig + dest);
                    socket.emit('makeMove', orig + dest + 'q');
                    socket.emit('makeMove', chessSquareToCheckersIndex(orig) + "-" + chessSquareToCheckersIndex(dest));
                },
                dropNewPiece: (role, key) => {
                    // called when a new piece is dropped from pocket
                    // add to position
                }
            }

        };

        let gameBoard = document.getElementById("gameboard");
        let gameBoardInside = document.getElementsByTagName("cg-board")[0];
        let oldDimensions = {width: 8, height: 8};

        function loadMainScript() {
            socket = io();

            socket.once('connect', () => {
                socket.emit('joinRoom', roomId, window.localStorage.getItem('authid'), window.localStorage.getItem('authpassword'));
            });

            document.getElementById('gamestatus').innerHTML = "Room {{RoomId}}";


            document.getElementById("movebutton").addEventListener('click', () => {
                socket.emit('makeMove', document.getElementById("moveinput").value);
                document.getElementById("moveinput").value = "";
            });


            socket.on('moveMade', (newimagedatauri, newGameStatusText, gameInfo, yourTeam) => {
                if (document.getElementById("piecesstyle").innerHTML === "") {
                    if (gameInfo.gametype == "chess") {
                        document.getElementById("piecesstyle").innerHTML = `<link rel="stylesheet" href="/assets/stylesheets/chessground.pieces.css">`;
                    } else if (gameInfo.gametype == "checkers") {
                        document.getElementById("piecesstyle").innerHTML = `<link rel="stylesheet" href="/assets/stylesheets/chessground.checkerspieces.css">`;
                    }
                }
                if ((gameInfo.gametype === "chess" && !["amazons"].includes(gameInfo.variant)) || gameInfo.gametype === "checkers") {
                    document.getElementById("moveinput").style.display = "none";
                    document.getElementById("movebutton").style.display = "none";
                    document.getElementById("gameimage").style.display = "none";
                    gameBoard.style.display = "block";
                    document.getElementById("yourData").style.display = "block";
                    document.getElementById("otherData").style.display = "block";
                    chessgroundconfig.fen = gameInfo.fen;
                    chessgroundconfig.orientation = yourTeam;
                    chessgroundconfig.movable.color = yourTeam;
                    chessgroundconfig.movable.dests = getDests(gameInfo.legalMoves, gameInfo.boardDimensions.height);
                    chessgroundconfig.turnColor = (gameInfo.turn ? "white" : "black");
                    chessgroundconfig.dimensions = gameInfo.boardDimensions;
                    board = new ChessgroundJS(gameBoard, chessgroundconfig);
                    let otherTeam = (yourTeam == "white" ? "black" : "white");
                    if (gameInfo.gametype === "chess" && gameInfo.variant === "chess") {
                        document.getElementById("otherData").innerText = gameInfo[otherTeam + "Name"] + " (" + gameInfo[otherTeam + "Elo"] + ") " + gameInfo[otherTeam + "TimeFormatted"];
                        document.getElementById("yourData").innerText = gameInfo[yourTeam + "Name"] + " (" + gameInfo[yourTeam + "Elo"] + ") " + gameInfo[yourTeam + "TimeFormatted"];
                    } else {
                        document.getElementById("otherData").innerText = gameInfo[otherTeam + "Name"] + " " + gameInfo[otherTeam + "TimeFormatted"];
                        document.getElementById("yourData").innerText = gameInfo[yourTeam + "Name"] + " " + gameInfo[yourTeam + "TimeFormatted"];;
                    }
                    if (gameInfo.boardDimensions != oldDimensions) {
                        if (gameBoard.classList.contains(`board${oldDimensions.width}x${oldDimensions.height}`)) {
                            gameBoard.classList.remove(`board${oldDimensions.width}x${oldDimensions.height}`);
                        }
                        gameBoard.classList.add(`board${gameInfo.boardDimensions.width}x${gameInfo.boardDimensions.height}`);
                        oldDimensions = gameInfo.boardDimensions;
                    }
                    if (window.innerWidth >= 600) {
                        gameBoard.style.width = ((gameBoard.clientHeight / oldDimensions.height) * oldDimensions.width) + "px";
                    }else{
                        gameBoard.style.height = ((gameBoard.clientWidth / oldDimensions.width) * oldDimensions.height) + "px";
                    }

                    let pieces = document.getElementsByTagName("piece");
                    for (let index = 0; index < pieces.length; index++) {
                        const element = pieces[index];
                        let piecesize = (gameBoard.clientWidth > gameBoard.clientHeight ?  (gameBoard.clientHeight / oldDimensions.height) + "px" : (gameBoard.clientWidth / oldDimensions.width) + "px");
                        element.style.width = piecesize;
                        element.style.height = piecesize;
                    }
                } else {
                    document.getElementById("moveinput").style.display = "block";
                    document.getElementById("movebutton").style.display = "block";
                    document.getElementById("gameimage").style.display = "block";
                    gameBoard.style.display = "none";
                    document.getElementById("yourData").style.display = "none";
                    document.getElementById("otherData").style.display = "none";
                }

                document.getElementById("gameimage").src = newimagedatauri;
                document.getElementById('gamestatus').innerHTML = newGameStatusText;
            });
        }



        let interval = setInterval(() => {
            if (ChessgroundJS != null) {
                loadMainScript();
                clearInterval(interval);
            }
        }, 500);

        setInterval(() => {
            let squares = document.getElementsByTagName("square");
            for (let index = 0; index < squares.length; index++) {
                const element = squares[index];
                let squaresize = (gameBoard.clientWidth > gameBoard.clientHeight ?  (gameBoard.clientHeight / oldDimensions.height) + "px" : (gameBoard.clientWidth / oldDimensions.width) + "px");
                element.style.width = squaresize;
                element.style.height = squaresize;
            }
            let margin = ((document.body.clientWidth - gameBoard.clientWidth) / 2) + "px";
            gameBoard.style.marginLeft = margin;
            gameBoard.style.marginRight = margin;
        }, 400);
    </script>
</body>
</html>